'use client'

import { useState, useEffect, useCallback } from 'react'
import { useCart } from '@/contexts/CartContext'
import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import Image from 'next/image'
import Link from 'next/link'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faShoppingCart, faUser, faEnvelope, faPhone, faTrash, faArrowRight } from '@fortawesome/free-solid-svg-icons'
import { faPaypal as faPaypalBrand } from '@fortawesome/free-brands-svg-icons'
import CustomerLayout from '@/app/customer-layout'
import { getCustomLabel } from '@/utils/colorTranslations'
import Alert, { useAlerts } from '@/components/ui/Alert'
import './checkout.css'

interface CheckoutForm {
  firstName: string
  lastName: string
  email: string
  phone: string
  notes: string
}

declare global {
  interface Window {
    paypal?: any
    paypalRetryCount?: number
  }
}

export default function CheckoutPage() {
  console.log('CheckoutPage: Starting to render')

  function CheckoutContent() {
    const { state, removeItem, updateQuantity, clearCart } = useCart()
    const { data: session, status } = useSession()
    const router = useRouter()
    const { alerts, showSuccess, showError, showWarning, showInfo } = useAlerts()
    console.log('CheckoutPage: Cart state loaded', state)
    console.log('CheckoutPage: Cart state properties:', {
      totalItems: state.totalItems,
      totalPrice: state.totalPrice,
      totalSavings: state.totalSavings,
      subtotal: state.subtotal,
      itemsCount: state.items.length,
    })

    const [formData, setFormData] = useState<CheckoutForm>({
      firstName: '',
      lastName: '',
      email: '',
      phone: '',
      notes: '',
    })

    const [promoCode, setPromoCode] = useState('')
    const [promoCodeError, setPromoCodeError] = useState('')
    const [promoCodeSuccess, setPromoCodeSuccess] = useState('')
    const [appliedPromoCode, setAppliedPromoCode] = useState<{
      code: string
      discount: number
      type: 'percentage' | 'fixed'
      discountAmount?: number
    } | null>(null)
    const [isValidatingPromo, setIsValidatingPromo] = useState(false)

    // PayPal state
    const [paypalLoaded, setPaypalLoaded] = useState(false)
    const [paypalSdkError, setPaypalSdkError] = useState(false)
    const [isProcessingOrder, setIsProcessingOrder] = useState(false)
    const [currentOrderId, setCurrentOrderId] = useState<string | null>(null)
    const [selectedPaymentMethod, setSelectedPaymentMethod] = useState('paypal')
    const [paypalButtonsRendered, setPaypalButtonsRendered] = useState(false)

    // Load PayPal SDK with enhanced error handling and validation
    useEffect(() => {
      let mounted = true
      let loadTimeout

      const loadPayPalSDK = async () => {
        if (typeof window === 'undefined') return

        console.log('üîÑ Starting PayPal SDK loading process...')

        // Reset error state
        setPaypalSdkError(false)

        // Check if PayPal SDK is already fully loaded and functional
        if (window.paypal && window.paypal.Buttons && typeof window.paypal.Buttons === 'function') {
          console.log('‚úÖ PayPal SDK already fully loaded and functional')
          if (mounted) setPaypalLoaded(true)
          return
        }

        // Remove any existing broken scripts
        const existingScripts = document.querySelectorAll('script[src*="paypal.com/sdk"]')
        existingScripts.forEach((script) => {
          console.log('üóëÔ∏è Removing existing PayPal script')
          script.remove()
        })

        // Clear any existing PayPal objects
        if (window.paypal) {
          console.log('üóëÔ∏è Clearing existing PayPal object')
          delete window.paypal
        }

        console.log('üì• Loading fresh PayPal SDK...')

        // Get PayPal client ID from meta tag
        const clientIdMeta = document.querySelector('meta[name="paypal-client-id"]')
        const paypalClientId = clientIdMeta?.getAttribute('content')
        console.log('PayPal Client ID from meta tag:', paypalClientId)
        if (!paypalClientId) {
          console.error('PayPal Client ID not found in meta tag')
          setPaypalSdkError(true)
          return
        }
        const script = document.createElement('script')
        // Always use the full SDK URL with components=buttons and all required params
        script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}&currency=USD&intent=capture&components=buttons&locale=ar_EG&debug=false`
        console.log('PayPal SDK script URL:', script.src)
        script.async = true
        script.defer = true

        // Set a timeout for loading
        loadTimeout = setTimeout(() => {
          console.error('‚è∞ PayPal SDK loading timeout')
          if (mounted) {
            setPaypalSdkError(true)
            setPaypalLoaded(false)
          }
        }, 15000) // 15 second timeout

        script.onload = () => {
          clearTimeout(loadTimeout)
          console.log('üì¶ PayPal script loaded, waiting for SDK initialization...')

          // Wait for PayPal SDK to be fully initialized
          const checkPayPalReady = (attempts = 0) => {
            if (!mounted) return

            if (window.paypal && window.paypal.Buttons && typeof window.paypal.Buttons === 'function') {
              console.log('‚úÖ PayPal SDK fully initialized and ready')
              setPaypalLoaded(true)
              setPaypalSdkError(false)
            } else if (attempts < 30) {
              // 30 attempts = 15 seconds max wait
              console.log(`‚è≥ Waiting for PayPal SDK initialization... (attempt ${attempts + 1}/30)`)
              setTimeout(() => checkPayPalReady(attempts + 1), 500)
            } else {
              console.error('‚ùå PayPal SDK failed to initialize after loading')
              setPaypalSdkError(true)
              setPaypalLoaded(false)
            }
          }

          checkPayPalReady()
        }

        script.onerror = (error) => {
          clearTimeout(loadTimeout)
          console.error('‚ùå Failed to load PayPal SDK script:', error)
          if (mounted) {
            setPaypalSdkError(true)
            setPaypalLoaded(false)
          }
        }

        document.head.appendChild(script)
      }

      loadPayPalSDK()

      return () => {
        mounted = false
        if (loadTimeout) clearTimeout(loadTimeout)
      }
    }, [])

    // Enhanced PayPal button initialization with robust error handling
    const initializePayPalButtons = useCallback(() => {
      console.log('üîÑ Attempting PayPal button initialization...', {
        paypalLoaded,
        currentOrderId,
        windowPaypal: !!window.paypal,
        paypalButtons: !!window.paypal?.Buttons,
        paypalButtonsRendered,
        isProcessingOrder,
      })

      // Pre-flight checks
      if (!window.paypal) {
        console.error('‚ùå PayPal SDK not available')
        setPaypalSdkError(true)
        return
      }

      if (!window.paypal.Buttons || typeof window.paypal.Buttons !== 'function') {
        console.log('‚ö†Ô∏è PayPal Buttons not ready yet, will retry...')
        const retryCount = (window.paypalRetryCount || 0) + 1
        window.paypalRetryCount = retryCount

        if (retryCount <= 10) {
          // Increased retry limit
          console.log(`üîÑ Retry attempt ${retryCount}/10 in 1 second...`)
          setTimeout(() => {
            if (!paypalButtonsRendered) {
              // Only retry if buttons still not rendered
              initializePayPalButtons()
            }
          }, 1000)
        } else {
          console.error('‚ùå Max PayPal retry attempts reached')
          setPaypalSdkError(true)
        }
        return
      }

      if (!currentOrderId) {
        console.log('‚ö†Ô∏è No current order ID available')
        return
      }

      if (paypalButtonsRendered) {
        console.log('‚ö†Ô∏è PayPal buttons already rendered')
        return
      }

      if (isProcessingOrder) {
        console.log('‚ö†Ô∏è Order currently being processed, skipping button initialization')
        return
      }

      // Clear retry counter on successful validation
      window.paypalRetryCount = 0

      // Prepare container
      const paypalContainer = document.getElementById('paypal-button-container')
      if (!paypalContainer) {
        console.error('‚ùå PayPal button container not found')
        setTimeout(() => initializePayPalButtons(), 500) // Retry if container not ready
        return
      }

      // Clear existing content
      paypalContainer.innerHTML = ''

      console.log('‚úÖ All conditions met, rendering PayPal buttons for order:', currentOrderId)

      try {
        const buttonsInstance = window.paypal.Buttons({
          createOrder: async () => {
            try {
              console.log('üîÑ Creating PayPal order for order ID:', currentOrderId)

              const response = await fetch('/api/paypal/create-order', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ orderId: currentOrderId }),
              })

              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}))
                throw new Error(`Server error: ${response.status} - ${errorData.error || 'Unknown error'}`)
              }

              const data = await response.json()

              if (!data.paypalOrderId) {
                throw new Error('No PayPal order ID returned from server')
              }

              console.log('‚úÖ PayPal order created successfully:', data.paypalOrderId)
              return data.paypalOrderId
            } catch (error) {
              console.error('‚ùå Error creating PayPal order:', error)
              showError('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿØŸÅÿπ', 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿ∑ŸÑÿ® ÿßŸÑÿØŸÅÿπ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
              throw error
            }
          },
          onApprove: async (data) => {
            try {
              console.log('üîÑ Processing PayPal payment approval...', data.orderID)
              setIsProcessingOrder(true)

              const response = await fetch('/api/paypal/capture-payment', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  paypalOrderId: data.orderID,
                  orderId: currentOrderId,
                }),
              })

              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}))
                throw new Error(`Payment capture failed: ${response.status} - ${errorData.error || 'Unknown error'}`)
              }

              const result = await response.json()
              console.log('‚úÖ Payment captured successfully:', result)

              // Clear cart and redirect
              clearCart()
              router.push(`/checkout/success?orderId=${currentOrderId}`)
            } catch (error) {
              console.error('‚ùå Error capturing payment:', error)
              showError('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÖÿπÿßŸÖŸÑÿ©', 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
              setIsProcessingOrder(false)
            }
          },
          onError: (err) => {
            console.error('‚ùå PayPal payment error:', err)
            showError('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿØŸÅÿπ', 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿØŸÅÿπ. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
            setIsProcessingOrder(false)
            setPaypalSdkError(true)
            setPaypalButtonsRendered(false)
          },
          onCancel: (data) => {
            console.log('‚ÑπÔ∏è Payment cancelled by user:', data)
            showInfo('ÿ™ŸÖ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°', 'ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ')
            setIsProcessingOrder(false)
          },
          style: {
            layout: 'vertical',
            color: 'gold',
            shape: 'rect',
            label: 'paypal',
            height: 40,
          },
        })

        // Render buttons with error handling
        buttonsInstance
          .render('#paypal-button-container')
          .then(() => {
            console.log('‚úÖ PayPal buttons rendered successfully')
            setPaypalButtonsRendered(true)
            setPaypalSdkError(false)
          })
          .catch((error) => {
            console.error('‚ùå Failed to render PayPal buttons:', error)
            setPaypalSdkError(true)
            setPaypalButtonsRendered(false)

            // Clear container and show retry option
            if (paypalContainer) {
              paypalContainer.innerHTML = ''
            }
          })
      } catch (error) {
        console.error('‚ùå Error initializing PayPal buttons:', error)
        setPaypalSdkError(true)
        setPaypalButtonsRendered(false)
      }
    }, [paypalLoaded, currentOrderId, paypalButtonsRendered, isProcessingOrder, showError, showInfo, clearCart, router])

    // Enhanced PayPal SDK retry with better error handling
    const retryPayPalSDK = () => {
      console.log('üîÑ Retrying PayPal SDK loading...')
      setPaypalSdkError(false)
      setPaypalLoaded(false)
      setPaypalButtonsRendered(false)

      // Remove all existing PayPal scripts and objects
      const existingScripts = document.querySelectorAll('script[src*="paypal.com/sdk"]')
      existingScripts.forEach((script) => script.remove())

      if (window.paypal) {
        delete window.paypal
      }

      // Reset retry counter
      window.paypalRetryCount = 0

      // Trigger fresh SDK loading
      setTimeout(() => {
        // Get PayPal client ID from meta tag
        const clientIdMeta = document.querySelector('meta[name="paypal-client-id"]')
        const paypalClientId = clientIdMeta?.getAttribute('content')
        if (!paypalClientId) {
          console.error('PayPal Client ID not found in meta tag')
          setPaypalSdkError(true)
          return
        }
        const script = document.createElement('script')
        script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}&currency=USD&intent=capture&components=buttons&locale=ar_EG&debug=false`
        script.async = true

        script.onload = () => {
          console.log('üì¶ PayPal SDK retry - script loaded, checking initialization...')

          const checkRetryReady = (attempts = 0) => {
            if (window.paypal && window.paypal.Buttons && typeof window.paypal.Buttons === 'function') {
              console.log('‚úÖ PayPal SDK retry successful')
              setPaypalLoaded(true)
              setPaypalSdkError(false)
            } else if (attempts < 20) {
              setTimeout(() => checkRetryReady(attempts + 1), 500)
            } else {
              console.error('‚ùå PayPal SDK retry failed to initialize')
              setPaypalSdkError(true)
            }
          }

          checkRetryReady()
        }

        script.onerror = () => {
          console.error('‚ùå PayPal SDK retry - script failed to load')
          setPaypalSdkError(true)
          setPaypalLoaded(false)
        }

        document.head.appendChild(script)
      }, 1000) // Wait 1 second before retry
    }

    // Enhanced PayPal button initialization trigger with better timing
    useEffect(() => {
      // Only initialize if all conditions are perfectly met
      const shouldInitialize =
        paypalLoaded &&
        currentOrderId &&
        !paypalButtonsRendered &&
        !isProcessingOrder &&
        window.paypal &&
        window.paypal.Buttons &&
        typeof window.paypal.Buttons === 'function'

      if (shouldInitialize) {
        console.log('üéØ All conditions met, initializing PayPal buttons...')

        // Wait a bit to ensure DOM is fully ready and any previous operations completed
        const timer = setTimeout(() => {
          // Double-check conditions before proceeding (race condition safety)
          if (paypalLoaded && currentOrderId && !paypalButtonsRendered && !isProcessingOrder) {
            initializePayPalButtons()
          } else {
            console.log('‚ö†Ô∏è Conditions changed during timeout, skipping initialization')
          }
        }, 300) // Reduced delay but still enough for DOM readiness

        return () => {
          clearTimeout(timer)
        }
      } else {
        console.log('‚è≥ PayPal button initialization conditions not met:', {
          paypalLoaded,
          currentOrderId: !!currentOrderId,
          paypalButtonsRendered,
          isProcessingOrder,
          windowPaypal: !!window.paypal,
          paypalButtons: !!(window.paypal && window.paypal.Buttons),
        })
      }
    }, [paypalLoaded, currentOrderId, paypalButtonsRendered, isProcessingOrder, initializePayPalButtons])

    // Reset PayPal buttons when order changes
    useEffect(() => {
      if (currentOrderId) {
        setPaypalButtonsRendered(false)
        const container = document.getElementById('paypal-button-container')
        if (container) {
          container.innerHTML = ''
        }
      }
    }, [currentOrderId])

    // Redirect if not logged in
    useEffect(() => {
      if (status === 'loading') return // Still loading

      if (!session?.user) {
        router.push('/auth/signin?redirect=/checkout')
      }
    }, [session, status, router])

    // Pre-fill form with user data if logged in
    useEffect(() => {
      if (session?.user) {
        const userName = session.user.name || ''
        const nameParts = userName.split(' ')

        setFormData((prev) => ({
          ...prev,
          firstName: nameParts[0] || '',
          lastName: nameParts.slice(1).join(' ') || '',
          email: session.user.email || '',
        }))
      }
    }, [session])

    // Show loading while checking authentication
    if (status === 'loading') {
      return (
        <div className="container">
          <div className="checkout-loading">
            <div className="loading-spinner"></div>
            <p>ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ...</p>
          </div>
        </div>
      )
    }

    // Don't render if not authenticated
    if (!session?.user) {
      return null
    }

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      const { name, value } = e.target
      setFormData((prev) => ({
        ...prev,
        [name]: value,
      }))
    }

    const handleQuantityChange = (cartItemId: string, newQuantity: number) => {
      if (newQuantity <= 0) {
        removeItem(cartItemId)
      } else {
        updateQuantity(cartItemId, newQuantity)
      }
    }

    const handlePromoCodeValidation = async () => {
      if (!promoCode.trim()) {
        setPromoCodeError('Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ')
        return
      }

      setIsValidatingPromo(true)
      setPromoCodeError('')
      setPromoCodeSuccess('')

      try {
        const response = await fetch('/api/promo-codes/validate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            code: promoCode.trim(),
            orderValue: state.subtotal || 0, // Original subtotal for minimum order checks
            currentTotal: state.totalPrice || 0, // Current total after existing discounts for promo calculation
            cartItems: state.items || [], // Send cart items for product-specific promo codes
          }),
        })

        const data = await response.json()

        if (response.ok) {
          setAppliedPromoCode({
            code: data.code,
            discount: data.discount || 0, // Add fallback
            type: data.type,
            discountAmount: data.discountAmount || 0, // Include the total discount amount
          })

          // Create a more detailed success message
          const itemText = data.totalQualifyingItems > 1 ? `${data.totalQualifyingItems} ÿπŸÜÿßÿµÿ±` : 'ÿπŸÜÿµÿ± Ÿàÿßÿ≠ÿØ'
          const discountText = data.type === 'percentage' ? `${data.discount || 0}%` : `$${data.discount || 0} ŸÑŸÉŸÑ ÿπŸÜÿµÿ±`

          setPromoCodeSuccess(
            `ÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ ÿπŸÑŸâ ${itemText}! ÿÆÿµŸÖ ${discountText} - ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿÆÿµŸÖ: $${(
              data.discountAmount || 0
            ).toFixed(2)}`
          )
          setPromoCode('')
        } else {
          setPromoCodeError(data.message || 'ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠')
        }
      } catch (error) {
        console.error('Promo code validation error:', error)
        setPromoCodeError('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ')
      } finally {
        setIsValidatingPromo(false)
      }
    }

    const removePromoCode = () => {
      setAppliedPromoCode(null)
      setPromoCodeSuccess('')
    }

    const handleSubmit = async (e) => {
      e.preventDefault()

      // Prevent multiple submissions
      if (isProcessingOrder) {
        console.log('‚ö†Ô∏è Already processing order, ignoring duplicate submission')
        return
      }

      // Validate form
      if (!formData.firstName || !formData.lastName || !formData.email) {
        showError('ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ∑ŸÑŸàÿ®ÿ©', 'Ÿäÿ±ÿ¨Ÿâ ŸÖŸÑÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©')
        return
      }

      if (selectedPaymentMethod !== 'paypal') {
        showWarning('ÿ∑ÿ±ŸäŸÇÿ© ÿØŸÅÿπ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©', 'ÿ≠ÿßŸÑŸäÿßŸãÿå ÿØŸÅÿπ PayPal ŸáŸà ÿßŸÑÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸàÿ≠ŸäÿØÿ© ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©')
        return
      }

      try {
        setIsProcessingOrder(true)
        console.log('üîÑ Starting order creation process...')

        // Calculate final total and actual discount amount
        // Use the discount amount calculated by the API for product-specific promo codes
        const subtotalAmount = state.subtotal || 0 // Original subtotal for proportional distribution
        const currentTotal = state.totalPrice || 0 // Current total after existing discounts
        const promoDiscountAmount = appliedPromoCode
          ? appliedPromoCode.discountAmount ?? // Use API-calculated discount amount if available
            (appliedPromoCode.type === 'percentage'
              ? (currentTotal * appliedPromoCode.discount) / 100 // Fallback to percentage calculation
              : Math.min(appliedPromoCode.discount, currentTotal)) // Fixed amount can't exceed current total
          : 0

        // Final total = current cart total (after product discounts) - promo discount
        // Ensure final total is never negative (minimum 0)
        const finalTotal = Math.max(0, currentTotal - promoDiscountAmount)

        console.log('üí∞ Pricing calculation:', {
          subtotal: subtotalAmount,
          currentTotal: currentTotal,
          promoCode: appliedPromoCode,
          promoDiscountAmount: promoDiscountAmount,
          finalTotal,
          isFreeOrder: finalTotal === 0,
          itemBreakdown: state.items.map((item) => {
            const itemSubtotal = (item.originalPrice || item.price) * item.quantity
            const itemPromoDiscount =
              promoDiscountAmount > 0 ? (itemSubtotal / subtotalAmount) * promoDiscountAmount : 0
            return {
              name: item.name,
              itemSubtotal,
              itemPromoDiscount: itemPromoDiscount.toFixed(2),
            }
          }),
        })

        // Create order in database
        const orderResponse = await fetch('/api/orders/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            customerName: `${formData.firstName} ${formData.lastName}`,
            customerEmail: formData.email,
            customerPhone: formData.phone,
            items: state.items.map((item) => {
              // Calculate promo discount per item (proportional to item value)
              const itemSubtotal = (item.originalPrice || item.price) * item.quantity
              const itemPromoDiscount =
                promoDiscountAmount > 0 ? (itemSubtotal / subtotalAmount) * promoDiscountAmount : 0

              return {
                productId: item.id,
                productName: item.name,
                productSlug: item.name.toLowerCase().replace(/\s+/g, '-'),
                quantity: item.quantity,
                originalPrice: item.originalPrice || item.price,
                discountAmount: (item.originalPrice || item.price) - item.price,
                unitPrice: item.price,
                totalPrice: Math.max(0, item.price * item.quantity - itemPromoDiscount), // Ensure never negative
                promoCode: appliedPromoCode?.code || '',
                promoDiscount: itemPromoDiscount,
                EnableCustomizations: item.EnableCustomizations || false, // Add EnableCustomizations flag
                hasCustomizations: !!(
                  (
                    item.customizations &&
                    (item.customizations.textChanges?.length ||
                      item.customizations.uploadedImages?.length ||
                      item.customizations.uploadedLogo ||
                      item.customizations.customizationNotes)
                  )
                  // NOTE: Predefined color selections are NOT customizations
                  // They are product variants that can be auto-delivered if files exist
                ),
                customizations: item.customizations,
              }
            }),
            subtotal: state.subtotal || 0,
            totalPromoDiscount: promoDiscountAmount,
            totalPrice: finalTotal,
            appliedPromoCodes: appliedPromoCode ? [appliedPromoCode.code] : [],
            customerNotes: formData.notes,
          }),
        })

        if (!orderResponse.ok) {
          const errorData = await orderResponse.json()
          throw new Error(errorData.message || 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®')
        }

        const orderData = await orderResponse.json()
        console.log('Order created successfully:', orderData)

        // Handle free orders (total <= 0) - check for customizable products
        if (finalTotal <= 0) {
          console.log('üéâ Processing free order - checking for customizable products')

          try {
            // Check if any products have EnableCustomizations: true (not actual customization data)
            const hasCustomizableProducts = orderData.hasCustomizableProducts

            // Also check if any products have actual customization data provided
            const hasActualCustomizations = state.items.some((item) => {
              return (
                item.customizations &&
                ((item.customizations.colors && item.customizations.colors.length > 0) ||
                  (item.customizations.textChanges && item.customizations.textChanges.length > 0) ||
                  (item.customizations.uploadedImages && item.customizations.uploadedImages.length > 0) ||
                  item.customizations.uploadedLogo ||
                  (item.customizations.customizationNotes && item.customizations.customizationNotes.trim().length > 0))
              )
            })

            console.log('üîç Free order analysis:', {
              hasCustomizableProducts,
              hasActualCustomizations,
              finalTotal,
            })

            if (hasCustomizableProducts && !hasActualCustomizations) {
              // Products CAN be customized but NO customization data provided - mark as processing with custom work
              console.log('‚ö†Ô∏è Free order has customizable products but missing customization data')

              await fetch('/api/orders/update-status', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                  status: 'processing',
                  paymentStatus: 'free',
                  deliveryType: 'custom_work',
                  note: 'ÿ∑ŸÑÿ® ŸÖÿ¨ÿßŸÜŸä Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ™ÿÆÿµŸäÿµ ŸàŸÑŸÉŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿÆÿµŸäÿµ ŸÖŸÅŸÇŸàÿØÿ©',
                }),
              })

              // Send customer notification email
              await fetch('/api/orders/send-customer-email', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                  orderNumber: orderData.orderNumber,
                  isFreeOrder: true,
                  missingCustomization: true,
                }),
              })

              // Send admin notification
              try {
                console.log('üîî Sending admin notification for free order with missing customizations...')
                const adminNotifyResponse = await fetch('/api/admin/notify-new-order', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    orderId: orderData.orderId,
                    orderNumber: orderData.orderNumber,
                    isFreeOrder: true,
                    hasCustomizations: true,
                    missingCustomization: true,
                    autoCompleted: false,
                  }),
                })

                const adminNotifyResult = await adminNotifyResponse.json()
                if (adminNotifyResponse.ok) {
                  console.log('‚úÖ Admin notification sent successfully:', adminNotifyResult)
                } else {
                  console.error('‚ùå Admin notification failed:', adminNotifyResult)
                }
              } catch (adminError) {
                console.error('‚ùå Error sending admin notification:', adminError)
              }

              showSuccess(
                'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑŸÖÿ¨ÿßŸÜŸä!',
                'ÿ∑ŸÑÿ®ŸÉ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ™ÿÆÿµŸäÿµ. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™ÿÆÿµŸäÿµ ÿ£Ÿà ÿ≥Ÿäÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ŸÅÿ±ŸäŸÇŸÜÿß.'
              )

              clearCart()
              router.push(`/checkout/success?order=${orderData.orderNumber}&free=true&pending=true`)
              return
            } else if (hasCustomizableProducts && hasActualCustomizations) {
              // Products have customization data provided - needs admin review
              console.log('üìã Free order has customizable products with data - needs admin review')

              await fetch('/api/orders/update-status', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                  status: 'pending',
                  paymentStatus: 'free',
                  note: 'ÿ∑ŸÑÿ® ŸÖÿ¨ÿßŸÜŸä Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ™ÿÆÿµŸäÿµÿßÿ™ ŸàŸäÿ≠ÿ™ÿßÿ¨ ŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ•ÿØÿßÿ±ÿ©',
                }),
              })

              // Send customer notification email
              await fetch('/api/orders/send-customer-email', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                  orderNumber: orderData.orderNumber,
                  isFreeOrder: true,
                }),
              })

              // Send admin notification about new free order with customizations
              try {
                console.log('üîî Sending admin notification for free order with customizations...')
                const adminNotifyResponse = await fetch('/api/admin/notify-new-order', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    orderId: orderData.orderId,
                    orderNumber: orderData.orderNumber,
                    isFreeOrder: true,
                    hasCustomizations: true,
                    autoCompleted: false,
                  }),
                })

                const adminNotifyResult = await adminNotifyResponse.json()
                if (adminNotifyResponse.ok) {
                  console.log('‚úÖ Admin notification sent successfully:', adminNotifyResult)
                } else {
                  console.error('‚ùå Admin notification failed:', adminNotifyResult)
                }
              } catch (adminError) {
                console.error('‚ùå Error sending admin notification:', adminError)
              }

              showSuccess(
                'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑŸÖÿ¨ÿßŸÜŸä!',
                'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑŸÖÿ¨ÿßŸÜŸä! ÿ≥ŸäŸÇŸàŸÖ ŸÅÿ±ŸäŸÇŸÜÿß ÿ®ŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ™ÿÆÿµŸäÿµÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸàÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã.'
              )

              clearCart()
              router.push(`/checkout/success?order=${orderData.orderNumber}&free=true&pending=true`)
              return
            } else {
              // No customizable products - auto-complete free order
              console.log('‚úÖ Free order has no customizable products - auto-completing')

              await fetch('/api/orders/complete-free-order', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                }),
              })

              // Send customer notification email
              await fetch('/api/orders/send-customer-email', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  orderId: orderData.orderId,
                  orderNumber: orderData.orderNumber,
                  isFreeOrder: true,
                }),
              })

              // Send admin notification about completed free order
              try {
                console.log('üîî Sending admin notification for completed free order...')
                const adminNotifyResponse = await fetch('/api/admin/notify-new-order', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    orderId: orderData.orderId,
                    orderNumber: orderData.orderNumber,
                    isFreeOrder: true,
                    hasCustomizations: false,
                    autoCompleted: true,
                  }),
                })

                const adminNotifyResult = await adminNotifyResponse.json()
                if (adminNotifyResponse.ok) {
                  console.log('‚úÖ Admin notification sent successfully:', adminNotifyResult)
                } else {
                  console.error('‚ùå Admin notification failed:', adminNotifyResult)
                }
              } catch (adminError) {
                console.error('‚ùå Error sending admin notification:', adminError)
              }

              showSuccess(
                'ÿ™ŸÖ ÿ•ŸÉŸÖÿßŸÑ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑŸÖÿ¨ÿßŸÜŸä!',
                'ÿ™ŸÖ ÿ•ŸÉŸÖÿßŸÑ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑŸÖÿ¨ÿßŸÜŸä Ÿàÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅÿßÿ™! ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≠ŸÖŸäŸÑŸáÿß ŸÖŸÜ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä.'
              )

              clearCart()
              router.push(`/checkout/success?order=${orderData.orderNumber}&free=true&completed=true`)
              return
            }
          } catch (error) {
            console.error('Error processing free order:', error)
            showError('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÖÿ¨ÿßŸÜŸä', 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÖÿ¨ÿßŸÜŸä. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
            return
          }
        }

        // For paid orders, continue with PayPal flow
        // Reset PayPal button state and set new order ID
        setPaypalButtonsRendered(false)
        setCurrentOrderId(orderData.orderId)

        // PayPal buttons will be initialized by the useEffect hook
      } catch (error) {
        console.error('Error creating order:', error)
        const errorMessage = error instanceof Error ? error.message : 'Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ'
        showError('ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®', `ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®: ${errorMessage}`)
      } finally {
        setIsProcessingOrder(false)
      }
    }

    // Debug: Check for corrupted cart data
    const hasCorruptedData = state.items.some(
      (item) => item.price < 0 || (item.originalPrice && item.originalPrice < item.price) || item.quantity <= 0
    )

    if (hasCorruptedData) {
      console.error('Corrupted cart data detected:', state.items)
      return (
        <div className="container">
          <div className="checkout-empty">
            <div className="checkout-empty-icon">
              <FontAwesomeIcon icon={faShoppingCart} />
            </div>
            <h2>ÿÆÿ∑ÿ£ ŸÅŸä ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≥ŸÑÿ©</h2>
            <p>ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ© ŸÅŸä ÿßŸÑÿ≥ŸÑÿ©. ÿ≥Ÿäÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿ≥ŸÑÿ© Ÿàÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©.</p>
            <button
              onClick={() => {
                clearCart()
                window.location.reload()
              }}
              className="btn btn-primary"
            >
              ŸÖÿ≥ÿ≠ ÿßŸÑÿ≥ŸÑÿ© Ÿàÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
            </button>
          </div>
        </div>
      )
    }

    if (state.items.length === 0) {
      return (
        <div className="container">
          <div className="checkout-empty">
            <div className="checkout-empty-icon">
              <FontAwesomeIcon icon={faShoppingCart} />
            </div>
            <h2>ÿßŸÑÿ≥ŸÑÿ© ŸÅÿßÿ±ÿ∫ÿ©</h2>
            <Link href="/" className="btn btn-primary">
              ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ™ÿ≥ŸàŸÇ
            </Link>
          </div>
        </div>
      )
    }

    return (
      <div className="container">
        {/* Alerts Container */}
        <div className="alerts-container">
          {alerts.map((alert, index) => (
            <Alert
              key={index}
              type={alert.type}
              title={alert.title}
              message={alert.message}
              duration={alert.duration}
              onClose={alert.onClose}
            />
          ))}
        </div>

        <div className="checkout-header">
          <h1>ÿßÿ™ŸÖÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®</h1>
          <p>ÿ£ŸÉŸÖŸÑ ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ ŸÑÿ•ÿ™ŸÖÿßŸÖ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°</p>
        </div>

        <div className="checkout-container">
          {/* Order Summary */}
          <div className="checkout-summary">
            <div className="summary-header">
              <h3>ŸÖŸÑÿÆÿµ ÿßŸÑÿ∑ŸÑÿ®</h3>
              <span className="items-count">{state.totalItems} ŸÖŸÜÿ™ÿ¨</span>
            </div>

            <div className="order-items">
              {state.items.map((item, index) => (
                <div className="order-item" key={item.cartItemId}>
                  <div className="item-image">
                    <Image
                      src={item.image}
                      alt={item.name}
                      width={100}
                      height={100}
                      style={{ objectFit: 'contain' }}
                      priority={index === 0}
                    />
                  </div>
                  <div className="item-details">
                    <h4>
                      {item.name}
                      {getCustomLabel(item.customizations) && (
                        <span className="custom-label"> ({getCustomLabel(item.customizations)})</span>
                      )}
                    </h4>
                    {item.customizations?.colors && item.customizations.colors.length > 0 && (
                      <p className="item-colors">ÿßŸÑÿ£ŸÑŸàÿßŸÜ: {item.customizations.colors.map((c) => c.name).join(', ')}</p>
                    )}
                    <div className="item-pricing">
                      {item.originalPrice && item.originalPrice > item.price ? (
                        <>
                          <div className="item-original-price">${item.originalPrice}</div>
                          <div className="item-final-price">${item.price}</div>
                        </>
                      ) : (
                        <div className="item-price">${item.price}</div>
                      )}
                    </div>
                  </div>
                  <div className="item-quantity">
                    <button
                      onClick={() => handleQuantityChange(item.cartItemId, item.quantity - 1)}
                      className="quantity-btn"
                    >
                      -
                    </button>
                    <span>{item.quantity}</span>
                    <button
                      onClick={() => handleQuantityChange(item.cartItemId, item.quantity + 1)}
                      className="quantity-btn"
                    >
                      +
                    </button>
                  </div>
                  <div className="item-total">${(item.price * item.quantity).toFixed(2)}</div>
                  <button onClick={() => removeItem(item.cartItemId)} className="remove-btn" title="ÿ•ÿ≤ÿßŸÑÿ©">
                    <FontAwesomeIcon icon={faTrash} />
                  </button>
                </div>
              ))}
            </div>

            {/* Promo Code Section */}
            <div className="promo-code-section">
              <h4>ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ</h4>
              {!appliedPromoCode ? (
                <div className="promo-code-input">
                  <input
                    type="text"
                    value={promoCode}
                    onChange={(e) => setPromoCode(e.target.value)}
                    placeholder="ÿ£ÿØÿÆŸÑ ŸÉŸàÿØ ÿßŸÑÿÆÿµŸÖ"
                    className="promo-input"
                    disabled={isValidatingPromo}
                  />
                  <button
                    onClick={handlePromoCodeValidation}
                    disabled={isValidatingPromo || !promoCode.trim()}
                    className="promo-btn"
                  >
                    {isValidatingPromo ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ...' : 'ÿ™ÿ∑ÿ®ŸäŸÇ'}
                  </button>
                </div>
              ) : (
                <div className="applied-promo">
                  <span className="promo-code-text">{appliedPromoCode.code}</span>
                  <button onClick={removePromoCode} className="remove-promo-btn">
                    ÿ•ÿ≤ÿßŸÑÿ©
                  </button>
                </div>
              )}
              {promoCodeError && <div className="promo-error">{promoCodeError}</div>}
              {promoCodeSuccess && <div className="promo-success">{promoCodeSuccess}</div>}
            </div>

            <div className="order-totals">
              <div className="total-row">
                <span>ÿßŸÑŸÖÿ¨ŸÖŸàÿπ ÿßŸÑŸÅÿ±ÿπŸä:</span>
                <span>${(state.subtotal || 0).toFixed(2)}</span>
              </div>
              {(state.totalSavings || 0) > 0 && (
                <div className="total-row">
                  <span>ÿÆÿµŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™:</span>
                  <span>-${(state.totalSavings || 0).toFixed(2)}</span>
                </div>
              )}
              {appliedPromoCode && (
                <div className="total-row">
                  <span>ÿÆÿµŸÖ ÿßŸÑŸÉŸàÿ®ŸàŸÜ:</span>
                  <span>
                    -$
                    {(
                      appliedPromoCode.discountAmount ||
                      // Fallback calculation if discountAmount is not provided
                      Math.min(
                        appliedPromoCode.type === 'percentage'
                          ? ((state.totalPrice || 0) * (appliedPromoCode.discount || 0)) / 100
                          : appliedPromoCode.discount || 0,
                        state.totalPrice || 0
                      )
                    ).toFixed(2)}
                  </span>
                </div>
              )}
              <div className="total-row final-total">
                <span>ÿßŸÑŸÖÿ¨ŸÖŸàÿπ ÿßŸÑŸÜŸáÿßÿ¶Ÿä:</span>
                <span>
                  $
                  {Math.max(
                    0,
                    (state.totalPrice || 0) -
                      (appliedPromoCode?.discountAmount ||
                        // Fallback calculation if discountAmount is not provided
                        Math.min(
                          appliedPromoCode
                            ? appliedPromoCode.type === 'percentage'
                              ? ((state.totalPrice || 0) * appliedPromoCode.discount) / 100
                              : appliedPromoCode.discount
                            : 0,
                          state.totalPrice || 0
                        ))
                  ).toFixed(2)}
                </span>
              </div>
            </div>
          </div>

          {/* Checkout Form */}
          <div className="checkout-form">
            <form onSubmit={handleSubmit}>
              <div className="form-section">
                <h3>ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©</h3>
                <div className="form-row">
                  <div className="form-group">
                    <label>
                      <FontAwesomeIcon icon={faUser} />
                      ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ£ŸàŸÑ
                    </label>
                    <input
                      type="text"
                      name="firstName"
                      value={formData.firstName}
                      onChange={handleInputChange}
                      required
                    />
                  </div>
                  <div className="form-group">
                    <label>
                      <FontAwesomeIcon icon={faUser} />
                      ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ£ÿÆŸäÿ±
                    </label>
                    <input
                      type="text"
                      name="lastName"
                      value={formData.lastName}
                      onChange={handleInputChange}
                      required
                    />
                  </div>
                </div>

                <div className="form-row">
                  <div className="form-group">
                    <label>
                      <FontAwesomeIcon icon={faEnvelope} />
                      ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
                    </label>
                    <input type="email" name="email" value={formData.email} onChange={handleInputChange} required />
                  </div>
                  <div className="form-group">
                    <label>
                      <FontAwesomeIcon icon={faPhone} />
                      ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÖÿπ ŸÖŸÇÿØŸÖÿ© ÿßŸÑÿØŸàŸÑÿ©
                    </label>
                    <input type="tel" name="phone" value={formData.phone} onChange={handleInputChange} required />
                  </div>
                </div>
              </div>

              <div className="form-section">
                <h3>ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©</h3>
                <div className="form-group">
                  <label>ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿßŸÑÿ∑ŸÑÿ® (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)</label>
                  <textarea
                    name="notes"
                    value={formData.notes}
                    onChange={handleInputChange}
                    rows={3}
                    placeholder="ÿ£ÿ∂ŸÅ ÿ£Ÿä ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ∑ŸÑÿ®..."
                  />
                </div>
              </div>

              <div className="form-section">
                <h3>ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ</h3>
                <div className="payment-methods">
                  <div className="payment-method">
                    <input
                      type="radio"
                      id="paypal"
                      name="payment"
                      value="paypal"
                      checked={selectedPaymentMethod === 'paypal'}
                      onChange={(e) => setSelectedPaymentMethod(e.target.value)}
                    />
                    <label htmlFor="paypal">
                      <FontAwesomeIcon icon={faPaypalBrand} />
                      PayPal & Credit Cards
                      {!paypalLoaded && !paypalSdkError && <span className="loading-text"> (ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...)</span>}
                      {paypalSdkError && <span className="error-text"> (ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ)</span>}
                      {paypalLoaded && <span className="success-text"> ‚úì</span>}
                    </label>
                  </div>
                </div>

                {selectedPaymentMethod === 'paypal' && (
                  <div className="payment-info">
                    <p className="payment-description">
                      üí≥ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿØŸÅÿπ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ≠ÿ≥ÿßÿ® PayPal ÿ£Ÿà ÿ®ÿ∑ÿßŸÇÿ© ÿßÿ¶ÿ™ŸÖÿßŸÜ/ÿÆÿµŸÖ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿØŸàŸÜ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® PayPal
                    </p>
                    <div className="supported-cards">
                      <small>ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑŸÖŸÇÿ®ŸàŸÑÿ©: Visa, Mastercard, American Express, Discover</small>
                    </div>
                  </div>
                )}

                {/* PayPal buttons container - shows after order is created */}
                {currentOrderId && (
                  <div className="paypal-buttons-section">
                    <h4>ÿ•ÿ™ŸÖÿßŸÖ ÿßŸÑÿØŸÅÿπ</h4>
                    {paypalLoaded ? (
                      <div className="paypal-container-wrapper">
                        <div id="paypal-button-container"></div>

                        {/* Loading overlay - positioned absolutely over the container */}
                        {!paypalButtonsRendered && !isProcessingOrder && !paypalSdkError && (
                          <div className="paypal-loading-overlay">
                            <div className="loading-spinner"></div>
                            <p>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿØŸÅÿπ...</p>
                            <small>ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ± ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿå Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©</small>
                          </div>
                        )}

                        {/* Processing overlay */}
                        {isProcessingOrder && (
                          <div className="paypal-processing-overlay">
                            <div className="loading-spinner"></div>
                            <p>ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ...</p>
                            <small>ŸÑÿß ÿ™ÿ∫ŸÑŸÇ Ÿáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ© ÿ≠ÿ™Ÿâ ÿßŸÉÿ™ŸÖÿßŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ©</small>
                          </div>
                        )}

                        {/* Button rendering error */}
                        {paypalSdkError && paypalLoaded && (
                          <div className="paypal-error">
                            <p>‚ö†Ô∏è ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿØŸÅÿπ</p>
                            <button
                              onClick={() => {
                                setPaypalSdkError(false)
                                setPaypalButtonsRendered(false)
                                setTimeout(() => initializePayPalButtons(), 100)
                              }}
                              className="retry-btn"
                              type="button"
                            >
                              ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿØŸÅÿπ
                            </button>
                          </div>
                        )}
                      </div>
                    ) : paypalSdkError ? (
                      <div className="paypal-error">
                        <p>‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ PayPal</p>
                        <p>Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™ ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</p>
                        <div className="error-actions">
                          <button onClick={retryPayPalSDK} className="retry-btn" type="button">
                            ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ PayPal
                          </button>
                          <button onClick={() => window.location.reload()} className="reload-btn" type="button">
                            ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©
                          </button>
                        </div>
                      </div>
                    ) : (
                      <div className="loading-paypal">
                        <div className="loading-spinner"></div>
                        <p>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ PayPal...</p>
                        <div className="loading-progress">
                          <small>ŸÇÿØ Ÿäÿ≥ÿ™ÿ∫ÿ±ŸÇ Ÿáÿ∞ÿß ÿ®ÿ∂ÿπ ÿ´ŸàÿßŸÜŸê...</small>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Show submit button only if no order is created yet */}
              {!currentOrderId &&
                (() => {
                  // Calculate final total for button display
                  const currentTotal = state.totalPrice || 0
                  const promoDiscountAmount = appliedPromoCode
                    ? appliedPromoCode.type === 'percentage'
                      ? (currentTotal * appliedPromoCode.discount) / 100
                      : appliedPromoCode.discount
                    : 0
                  const finalTotal = Math.max(0, currentTotal - Math.min(promoDiscountAmount, currentTotal))
                  const isFreeOrder = finalTotal === 0

                  return (
                    <button
                      type="submit"
                      className="submit-order-btn"
                      disabled={
                        isProcessingOrder || (!paypalLoaded && !isFreeOrder) || (paypalSdkError && !isFreeOrder)
                      }
                    >
                      <span>
                        {isProcessingOrder
                          ? isFreeOrder
                            ? 'ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÖÿ¨ÿßŸÜŸä...'
                            : 'ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®...'
                          : isFreeOrder
                          ? 'ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÖÿ¨ÿßŸÜŸä'
                          : paypalSdkError
                          ? 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ PayPal - Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©'
                          : !paypalLoaded
                          ? 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ PayPal...'
                          : 'ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ŸàÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ© ŸÑŸÑÿØŸÅÿπ'}
                      </span>
                      <FontAwesomeIcon icon={faArrowRight} />
                    </button>
                  )
                })()}
            </form>
          </div>
        </div>
      </div>
    )
  }

  return (
    <CustomerLayout>
      <CheckoutContent />
    </CustomerLayout>
  )
}
